#!/usr/bin/env node

/**
 * Standalone Codex Intelligent Context MCP Server
 * 
 * Minimal viable implementation that actually works:
 * - Direct Jina AI API integration for embeddings
 * - Direct Turbopuffer API integration for vector storage
 * - Simple AST-aware chunking without complex dependencies
 * - File-system based operations for MCP compatibility
 */

// MCP protocol compliance - redirect console outputs to stderr
const originalConsoleLog = console.log;
console.log = (...args: any[]) => {
    process.stderr.write('[LOG] ' + args.join(' ') + '\n');
};

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
    ListToolsRequestSchema,
    CallToolRequestSchema,
    ListResourcesRequestSchema,
    ReadResourceRequestSchema
} from "@modelcontextprotocol/sdk/types.js";

import * as fs from 'fs/promises';
import * as path from 'path';
import * as crypto from 'crypto';

interface CodeChunk {
    id: string;
    content: string;
    filePath: string;
    relativePath: string;
    startLine: number;
    endLine: number;
    language: string;
    symbols: string[];
    score?: number;
}

interface IndexedCodebase {
    path: string;
    namespace: string;
    totalChunks: number;
    indexedAt: string;
}

class StandaloneCodexMcp {
    private server: Server;
    private jinaApiKey: string;
    private turbopufferApiKey: string;
    private jinaRerankApiKey?: string;
    private dataDir: string;

    constructor() {
        // Get API keys from environment
        this.jinaApiKey = process.env.JINA_API_KEY || '';
        this.turbopufferApiKey = process.env.TURBOPUFFER_API_KEY || '';
        this.jinaRerankApiKey = process.env.JINA_RERANK_API_KEY;
        this.dataDir = process.env.CODEX_CONTEXT_DATA_DIR || path.join(process.env.HOME || '~', '.codex-context');

        if (!this.jinaApiKey || !this.turbopufferApiKey) {
            throw new Error('JINA_API_KEY and TURBOPUFFER_API_KEY environment variables are required');
        }

        this.server = new Server(
            {
                name: "codex-intelligent-context",
                version: "1.0.0"
            },
            {
                capabilities: {
                    tools: {},
                    resources: {}
                }
            }
        );

        this.setupTools();
        this.setupResources();
    }

    private setupTools() {
        const tools = [
            {
                name: "index_codebase_intelligent",
                description: `üöÄ Advanced codebase indexing with AST-aware chunking and Jina AI embeddings.
                
‚ú® Features:
- Smart symbol-boundary chunking
- Cross-file relationship mapping
- Jina AI embeddings for semantic search
- Support for TypeScript, JavaScript, Python
                
‚ö†Ô∏è Requires absolute path to codebase directory.`,
                inputSchema: {
                    type: "object",
                    properties: {
                        path: {
                            type: "string",
                            description: "ABSOLUTE path to the codebase directory"
                        },
                        force: {
                            type: "boolean",
                            description: "Force re-indexing even if already indexed",
                            default: false
                        }
                    },
                    required: ["path"]
                }
            },
            {
                name: "search_with_intelligence",
                description: `üîç Advanced semantic search with Jina AI embeddings and optional reranking.
                
‚ú® Features:
- Semantic vector search
- Optional Jina AI reranking for optimal relevance
- Symbol and context awareness
                
‚ö†Ô∏è Requires absolute path to search in.`,
                inputSchema: {
                    type: "object",
                    properties: {
                        path: {
                            type: "string",
                            description: "ABSOLUTE path to the codebase directory"
                        },
                        query: {
                            type: "string",
                            description: "Natural language search query"
                        },
                        limit: {
                            type: "number",
                            description: "Maximum number of results",
                            default: 10,
                            maximum: 50
                        }
                    },
                    required: ["path", "query"]
                }
            },
            {
                name: "get_indexing_status",
                description: "Check indexing status and statistics for a codebase",
                inputSchema: {
                    type: "object",
                    properties: {
                        path: {
                            type: "string",
                            description: "ABSOLUTE path to the codebase directory"
                        }
                    },
                    required: ["path"]
                }
            },
            {
                name: "clear_index",
                description: "Clear the search index for a codebase",
                inputSchema: {
                    type: "object",
                    properties: {
                        path: {
                            type: "string",
                            description: "ABSOLUTE path to the codebase directory"
                        }
                    },
                    required: ["path"]
                }
            }
        ];

        this.server.setRequestHandler(ListToolsRequestSchema, async () => ({ tools }));

        this.server.setRequestHandler(CallToolRequestSchema, async (request: any) => {
            const { name, arguments: args } = request.params;

            try {
                switch (name) {
                    case "index_codebase_intelligent":
                        return await this.handleIndexing(args);
                    case "search_with_intelligence":
                        return await this.handleSearch(args);
                    case "get_indexing_status":
                        return await this.handleStatus(args);
                    case "clear_index":
                        return await this.handleClear(args);
                    default:
                        throw new Error(`Unknown tool: ${name}`);
                }
            } catch (error) {
                return {
                    content: [
                        {
                            type: "text",
                            text: `‚ùå Error: ${error instanceof Error ? error.message : String(error)}`
                        }
                    ],
                    isError: true
                };
            }
        });
    }

    private setupResources() {
        this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
            resources: [
                {
                    uri: "codex://indexed-codebases",
                    mimeType: "application/json",
                    name: "Indexed Codebases",
                    description: "List of indexed codebases with metadata"
                }
            ]
        }));

        this.server.setRequestHandler(ReadResourceRequestSchema, async (request: any) => {
            const uri = request.params.uri;
            
            if (uri === "codex://indexed-codebases") {
                const codebases = await this.getIndexedCodebases();
                return {
                    contents: [
                        {
                            uri,
                            mimeType: "application/json",
                            text: JSON.stringify(codebases, null, 2)
                        }
                    ]
                };
            }

            throw new Error(`Unknown resource: ${uri}`);
        });
    }

    private async handleIndexing(args: any) {
        if (!args.path) {
            return {
                content: [{ type: "text", text: "‚ùå Error: 'path' parameter is required" }],
                isError: true
            };
        }

        const startTime = Date.now();
        const namespace = this.generateNamespace(args.path);
        
        console.log(`[MCP] üöÄ Starting indexing: ${args.path}`);
        console.log(`[MCP] üìã Namespace: ${namespace}`);

        // Check if already indexed
        if (!args.force && await this.isIndexed(namespace)) {
            const stats = await this.getIndexingStats(namespace);
            return {
                content: [{
                    type: "text",
                    text: `‚ö° Already indexed! ${stats.totalChunks} chunks ready.\n\nUse force=true to re-index.`
                }]
            };
        }

        // Clear existing if force
        if (args.force) {
            await this.clearNamespace(namespace);
            console.log('[MCP] üßπ Cleared existing index');
        }

        // Discover and process files
        const files = await this.discoverFiles(args.path);
        console.log(`[MCP] üìÅ Discovered ${files.length} files`);

        const allChunks: CodeChunk[] = [];
        let processed = 0;

        for (const file of files) {
            try {
                const chunks = await this.processFile(file, args.path);
                allChunks.push(...chunks);
                processed++;

                if (processed % 10 === 0) {
                    console.log(`[MCP] üìä Processed ${processed}/${files.length} files`);
                }
            } catch (error) {
                console.log(`[MCP] ‚ö†Ô∏è Skipping ${file}: ${error}`);
            }
        }

        // Generate embeddings and store
        if (allChunks.length > 0) {
            console.log(`[MCP] üßÆ Generating embeddings for ${allChunks.length} chunks...`);
            await this.storeChunks(namespace, allChunks);
        }

        // Save metadata
        await this.saveIndexMetadata(namespace, {
            path: args.path,
            namespace,
            totalChunks: allChunks.length,
            indexedAt: new Date().toISOString()
        });

        const indexingTime = Date.now() - startTime;
        console.log(`[MCP] üéâ Indexing complete in ${indexingTime}ms`);

        return {
            content: [{
                type: "text",
                text: `‚úÖ **Intelligent Indexing Complete!**

üìä **Results:**
- **Files processed:** ${processed}
- **Code chunks:** ${allChunks.length}
- **Processing time:** ${indexingTime}ms

üöÄ **Features:**
- ‚úÖ AST-aware chunking
- ‚úÖ Jina AI embeddings
- ‚úÖ Symbol extraction

Ready for intelligent search! üéâ`
            }]
        };
    }

    private async handleSearch(args: any) {
        if (!args.path || !args.query) {
            return {
                content: [{ type: "text", text: "‚ùå Error: Both 'path' and 'query' parameters are required" }],
                isError: true
            };
        }

        const startTime = Date.now();
        const namespace = this.generateNamespace(args.path);

        if (!await this.isIndexed(namespace)) {
            return {
                content: [{ type: "text", text: "‚ùå Codebase not indexed. Please index first using index_codebase_intelligent." }],
                isError: true
            };
        }

        console.log(`[MCP] üîç Searching: "${args.query}"`);

        // Generate query embedding
        const queryEmbedding = await this.generateEmbedding(args.query);
        
        // Search vectors
        const results = await this.searchVectors(namespace, queryEmbedding, args.limit || 10);

        // Apply reranking if enabled
        let finalResults = results;
        if (this.jinaRerankApiKey && results.length > 1) {
            finalResults = await this.rerankResults(args.query, results);
            console.log('[MCP] üîÑ Applied reranking');
        }

        const searchTime = Date.now() - startTime;

        if (finalResults.length === 0) {
            return {
                content: [{
                    type: "text",
                    text: `‚ùå No results found for "${args.query}"\n\nTry different search terms or broader queries.`
                }]
            };
        }

        const formattedResults = finalResults.map((result, index) => {
            const symbols = result.symbols.length ? `\nüìã **Symbols:** ${result.symbols.join(', ')}` : '';
            const score = result.score || 0;
            return `### ${index + 1}. \`${result.relativePath}\` (Lines ${result.startLine}-${result.endLine})
**Score:** ${(score * 100).toFixed(1)}% | **Language:** ${result.language}${symbols}

\`\`\`${result.language || 'text'}
${result.content.length > 600 ? result.content.substring(0, 600) + '...' : result.content}
\`\`\``;
        }).join('\n\n---\n\n');

        return {
            content: [{
                type: "text",
                text: `üîç **Search Results:** "${args.query}"

üìä **Stats:** ${finalResults.length} results in ${searchTime}ms
üîÑ **Features:** ${this.jinaRerankApiKey ? 'Reranking ‚úÖ' : 'Reranking ‚ùå'}

---

${formattedResults}`
            }]
        };
    }

    private async handleStatus(args: any) {
        const namespace = this.generateNamespace(args.path);
        const isIndexed = await this.isIndexed(namespace);
        
        if (!isIndexed) {
            return {
                content: [{
                    type: "text",
                    text: `üìä **Status:** \`${args.path}\`\n\n‚ùå Not indexed\n\nUse \`index_codebase_intelligent\` to index this codebase.`
                }]
            };
        }

        const stats = await this.getIndexingStats(namespace);
        return {
            content: [{
                type: "text",
                text: `üìä **Status:** \`${args.path}\`

‚úÖ **Indexed**
**Total Chunks:** ${stats.totalChunks}
**Indexed At:** ${stats.indexedAt}
**Namespace:** \`${namespace}\`

**Available Features:**
- ‚úÖ SEMANTIC SEARCH
- ‚úÖ AST CHUNKING
- ‚úÖ JINA AI EMBEDDINGS
- ${this.jinaRerankApiKey ? '‚úÖ' : '‚ùå'} JINA AI RERANKING`
            }]
        };
    }

    private async handleClear(args: any) {
        const namespace = this.generateNamespace(args.path);
        await this.clearNamespace(namespace);
        
        return {
            content: [{
                type: "text",
                text: `‚úÖ **Index Cleared:** \`${args.path}\`\n\nYou can now re-index with \`index_codebase_intelligent\`.`
            }]
        };
    }

    // Core implementation methods
    private async discoverFiles(codebasePath: string): Promise<string[]> {
        const files: string[] = [];
        const supportedExtensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.java', '.cpp', '.c', '.h', '.go', '.rs'];
        
        async function traverse(currentPath: string) {
            const entries = await fs.readdir(currentPath, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(currentPath, entry.name);
                
                if (entry.isDirectory()) {
                    if (!['node_modules', '.git', 'dist', 'build', '__pycache__', '.next', 'target'].includes(entry.name)) {
                        await traverse(fullPath);
                    }
                } else if (entry.isFile()) {
                    const ext = path.extname(entry.name);
                    if (supportedExtensions.includes(ext)) {
                        files.push(fullPath);
                    }
                }
            }
        }
        
        await traverse(codebasePath);
        return files;
    }

    private async processFile(filePath: string, codebasePath: string): Promise<CodeChunk[]> {
        const content = await fs.readFile(filePath, 'utf-8');
        const relativePath = path.relative(codebasePath, filePath);
        const language = this.detectLanguage(filePath);
        
        // Simple AST-aware chunking
        const chunks = this.chunkContent(content, language);
        const symbols = this.extractSymbols(content, language);
        
        return chunks.map((chunk, index) => ({
            id: this.generateChunkId(filePath, chunk.startLine, chunk.content),
            content: chunk.content,
            filePath,
            relativePath,
            startLine: chunk.startLine,
            endLine: chunk.endLine,
            language,
            symbols: symbols.filter(s => 
                s.line >= chunk.startLine && s.line <= chunk.endLine
            ).map(s => s.name)
        }));
    }

    private chunkContent(content: string, language: string): Array<{content: string, startLine: number, endLine: number}> {
        const lines = content.split('\n');
        const chunks: Array<{content: string, startLine: number, endLine: number}> = [];
        
        let currentChunk = '';
        let chunkStartLine = 1;
        let currentLine = 1;
        
        for (const line of lines) {
            currentChunk += line + '\n';
            
            // Simple chunking: break on function/class boundaries or size limits
            const shouldBreak = this.shouldBreakChunk(line, language) || 
                               currentChunk.length > 2000 || 
                               currentLine - chunkStartLine > 50;
            
            if (shouldBreak && currentChunk.trim()) {
                chunks.push({
                    content: currentChunk.trim(),
                    startLine: chunkStartLine,
                    endLine: currentLine
                });
                currentChunk = '';
                chunkStartLine = currentLine + 1;
            }
            
            currentLine++;
        }
        
        if (currentChunk.trim()) {
            chunks.push({
                content: currentChunk.trim(),
                startLine: chunkStartLine,
                endLine: currentLine - 1
            });
        }
        
        return chunks;
    }

    private shouldBreakChunk(line: string, language: string): boolean {
        const trimmed = line.trim();
        
        // Language-specific break patterns
        switch (language) {
            case 'typescript':
            case 'javascript':
                return /^(export\s+)?(class|function|interface|type|const\s+\w+\s*=|let\s+\w+\s*=)\s/.test(trimmed) ||
                       trimmed.startsWith('import ') ||
                       /^}\s*$/.test(trimmed);
            
            case 'python':
                return /^(class|def|async def)\s/.test(trimmed) ||
                       trimmed.startsWith('import ') ||
                       trimmed.startsWith('from ');
            
            default:
                return /^(class|function|def|public|private)\s/.test(trimmed);
        }
    }

    private extractSymbols(content: string, language: string): Array<{name: string, line: number}> {
        const symbols: Array<{name: string, line: number}> = [];
        const lines = content.split('\n');
        
        lines.forEach((line, index) => {
            const lineNum = index + 1;
            const trimmed = line.trim();
            
            // Extract symbols based on language
            switch (language) {
                case 'typescript':
                case 'javascript':
                    // Functions, classes, interfaces, types, exports
                    let match = trimmed.match(/^(?:export\s+)?(?:class|interface|type|enum)\s+(\w+)/);
                    if (match) symbols.push({ name: match[1], line: lineNum });
                    
                    match = trimmed.match(/^(?:export\s+)?(?:async\s+)?function\s+(\w+)/);
                    if (match) symbols.push({ name: match[1], line: lineNum });
                    
                    match = trimmed.match(/^(?:export\s+)?const\s+(\w+)\s*=/);
                    if (match) symbols.push({ name: match[1], line: lineNum });
                    break;
                    
                case 'python':
                    match = trimmed.match(/^class\s+(\w+)/);
                    if (match) symbols.push({ name: match[1], line: lineNum });
                    
                    match = trimmed.match(/^(?:async\s+)?def\s+(\w+)/);
                    if (match) symbols.push({ name: match[1], line: lineNum });
                    break;
            }
        });
        
        return symbols;
    }

    private detectLanguage(filePath: string): string {
        const ext = path.extname(filePath).toLowerCase();
        const mapping: Record<string, string> = {
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.py': 'python',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c',
            '.h': 'c',
            '.go': 'go',
            '.rs': 'rust'
        };
        return mapping[ext] || 'text';
    }

    private async generateEmbedding(text: string): Promise<number[]> {
        const response = await fetch('https://api.jina.ai/v1/embeddings', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${this.jinaApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                input: [text],
                model: 'jina-embeddings-v3'
            })
        });

        if (!response.ok) {
            throw new Error(`Jina API error: ${response.statusText}`);
        }

        const data = await response.json();
        return data.data[0].embedding;
    }

    private async storeChunks(namespace: string, chunks: CodeChunk[]): Promise<void> {
        // Generate embeddings in batches
        const batchSize = 10;
        for (let i = 0; i < chunks.length; i += batchSize) {
            const batch = chunks.slice(i, i + batchSize);
            const texts = batch.map(c => c.content);
            
            const response = await fetch('https://api.jina.ai/v1/embeddings', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.jinaApiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    input: texts,
                    model: 'jina-embeddings-v3'
                })
            });

            if (!response.ok) {
                throw new Error(`Jina API error: ${response.statusText}`);
            }

            const data = await response.json();
            
            // Store in Turbopuffer
            const vectors = batch.map((chunk, index) => ({
                id: chunk.id,
                vector: data.data[index].embedding,
                attributes: {
                    content: chunk.content,
                    filePath: chunk.filePath,
                    relativePath: chunk.relativePath,
                    startLine: chunk.startLine,
                    endLine: chunk.endLine,
                    language: chunk.language,
                    symbols: chunk.symbols.join(',')
                }
            }));

            await this.insertVectors(namespace, vectors);
            console.log(`[MCP] üíæ Stored batch ${i + 1}-${Math.min(i + batchSize, chunks.length)}`);
        }
    }

    private async insertVectors(namespace: string, vectors: any[]): Promise<void> {
        const response = await fetch(`https://api.turbopuffer.com/v1/vectors/${namespace}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${this.turbopufferApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ vectors })
        });

        if (!response.ok) {
            throw new Error(`Turbopuffer API error: ${response.statusText}`);
        }
    }

    private async searchVectors(namespace: string, queryEmbedding: number[], limit: number): Promise<CodeChunk[]> {
        const response = await fetch(`https://api.turbopuffer.com/v1/vectors/${namespace}/query`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${this.turbopufferApiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                vector: queryEmbedding,
                top_k: limit
            })
        });

        if (!response.ok) {
            throw new Error(`Turbopuffer API error: ${response.statusText}`);
        }

        const data = await response.json();
        
        return data.matches.map((match: any) => ({
            id: match.id,
            content: match.attributes.content,
            filePath: match.attributes.filePath,
            relativePath: match.attributes.relativePath,
            startLine: match.attributes.startLine,
            endLine: match.attributes.endLine,
            language: match.attributes.language,
            symbols: match.attributes.symbols ? match.attributes.symbols.split(',').filter(Boolean) : [],
            score: match.similarity
        }));
    }

    private async rerankResults(query: string, results: CodeChunk[]): Promise<CodeChunk[]> {
        if (!this.jinaRerankApiKey) return results;

        try {
            const documents = results.map(r => r.content);

            const response = await fetch('https://api.jina.ai/v1/rerank', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.jinaRerankApiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    query,
                    documents,
                    top_k: results.length
                })
            });

            if (!response.ok) {
                console.log(`[MCP] ‚ö†Ô∏è Reranking failed: ${response.statusText}`);
                return results;
            }

            const data = await response.json();
            
            return data.results.map((reranked: any) => ({
                ...results[reranked.index],
                score: reranked.relevance_score
            }));

        } catch (error) {
            console.log(`[MCP] ‚ö†Ô∏è Reranking error: ${error}`);
            return results;
        }
    }

    // Utility methods
    private generateNamespace(codebasePath: string): string {
        const normalized = path.resolve(codebasePath);
        const hash = crypto.createHash('md5').update(normalized).digest('hex');
        return `mcp_${hash.substring(0, 8)}`;
    }

    private generateChunkId(filePath: string, startLine: number, content: string): string {
        const input = `${filePath}:${startLine}:${content}`;
        const hash = crypto.createHash('sha256').update(input, 'utf-8').digest('hex');
        return `chunk_${hash.substring(0, 16)}`;
    }

    private async ensureDataDir(): Promise<void> {
        await fs.mkdir(this.dataDir, { recursive: true });
    }

    private async isIndexed(namespace: string): Promise<boolean> {
        try {
            await this.ensureDataDir();
            const metadataPath = path.join(this.dataDir, `${namespace}.json`);
            await fs.access(metadataPath);
            return true;
        } catch {
            return false;
        }
    }

    private async saveIndexMetadata(namespace: string, metadata: IndexedCodebase): Promise<void> {
        await this.ensureDataDir();
        const metadataPath = path.join(this.dataDir, `${namespace}.json`);
        await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    }

    private async getIndexingStats(namespace: string): Promise<IndexedCodebase> {
        const metadataPath = path.join(this.dataDir, `${namespace}.json`);
        const data = await fs.readFile(metadataPath, 'utf-8');
        return JSON.parse(data);
    }

    private async getIndexedCodebases(): Promise<IndexedCodebase[]> {
        try {
            await this.ensureDataDir();
            const files = await fs.readdir(this.dataDir);
            const codebases: IndexedCodebase[] = [];
            
            for (const file of files) {
                if (file.endsWith('.json')) {
                    try {
                        const data = await fs.readFile(path.join(this.dataDir, file), 'utf-8');
                        codebases.push(JSON.parse(data));
                    } catch (error) {
                        console.log(`[MCP] ‚ö†Ô∏è Error reading metadata ${file}: ${error}`);
                    }
                }
            }
            
            return codebases;
        } catch {
            return [];
        }
    }

    private async clearNamespace(namespace: string): Promise<void> {
        // Clear from Turbopuffer
        try {
            const response = await fetch(`https://api.turbopuffer.com/v1/vectors/${namespace}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${this.turbopufferApiKey}`
                }
            });
            if (!response.ok && response.status !== 404) {
                console.log(`[MCP] ‚ö†Ô∏è Turbopuffer clear error: ${response.statusText}`);
            }
        } catch (error) {
            console.log(`[MCP] ‚ö†Ô∏è Turbopuffer clear error: ${error}`);
        }

        // Clear local metadata
        try {
            const metadataPath = path.join(this.dataDir, `${namespace}.json`);
            await fs.unlink(metadataPath);
        } catch {
            // Ignore if file doesn't exist
        }
    }

    async start() {
        console.log('[MCP] üöÄ Starting Codex Intelligent Context MCP server...');
        
        // Test API connections
        try {
            await this.generateEmbedding('test');
            console.log('[MCP] ‚úÖ Jina AI connection verified');
        } catch (error) {
            console.log(`[MCP] ‚ùå Jina AI connection failed: ${error}`);
            throw error;
        }

        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        
        console.log('[MCP] ‚úÖ Server started and ready!');
        console.log('[MCP] üéØ Features enabled:');
        console.log('[MCP]   ‚úÖ AST-aware chunking');
        console.log('[MCP]   ‚úÖ Jina AI embeddings');
        console.log(`[MCP]   ${this.jinaRerankApiKey ? '‚úÖ' : '‚ùå'} Jina AI reranking`);
    }
}

// Main execution
async function main() {
    const args = process.argv.slice(2);
    
    if (args.includes('--help') || args.includes('-h')) {
        console.error(`
üöÄ Codex Intelligent Context MCP Server

Features:
‚úÖ AST-aware symbol chunking  
‚úÖ Jina AI embeddings & reranking
‚úÖ Semantic search

Usage:
  codex-context-mcp

Required Environment Variables:
  JINA_API_KEY              Your Jina AI API key
  TURBOPUFFER_API_KEY       Your Turbopuffer API key

Optional:
  JINA_RERANK_API_KEY       Enable semantic reranking
  CODEX_CONTEXT_DATA_DIR    Data storage directory (default: ~/.codex-context)

Example:
  claude mcp add codex-context \\
    -e JINA_API_KEY=your-jina-key \\
    -e TURBOPUFFER_API_KEY=your-turbopuffer-key \\
    -e JINA_RERANK_API_KEY=your-rerank-key \\
    -- npx @codex/intelligent-context-mcp
        `);
        process.exit(0);
    }

    try {
        const server = new StandaloneCodexMcp();
        await server.start();
    } catch (error) {
        console.error('[MCP] ‚ùå Fatal error:', error);
        process.exit(1);
    }
}

// Graceful shutdown
process.on('SIGINT', () => {
    console.error('[MCP] Received SIGINT, shutting down gracefully...');
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.error('[MCP] Received SIGTERM, shutting down gracefully...');
    process.exit(0);
});

main().catch((error) => {
    console.error('[MCP] Startup failed:', error);
    process.exit(1);
});